FUNCTION_BLOCK "InSelect"
TITLE = 'Custom InSelect Block'
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : TI
FAMILY : NF1
NAME : InSelect
VERSION : 1.7

   VAR_INPUT 
      SAMPLE_T { CFC_Visible := 'false'; CFC_Interconnectable := 'false'} : Real := 0.1;   // Default Sample Time (in seconds)Has Assignable UnitsParameter to be translated to OSParameter to update auto in monitor
      IN01 { CFC_EngineeringUnit := '%'; CFC_ForTest := 'true'} : Real;   // Input 01  (Xmitter or Value)
      IN01_QBAD { CFC_ForTest := 'true'} : Bool;   // QBad from AI Block
      IN01_QC : Byte := BYTE#16#00;   // Quality Code for Input 01
      IN01_TX { CFC_Visible := 'true'; CFC_Interconnectable := 'false'} : String := 'A';   // Text Input max 4 StringHas Assignable UnitsParameter to be translated to OSParameter to update auto in monitor
      IN02 { CFC_EngineeringUnit := '%'; CFC_ForTest := 'true'} : Real;   // Input 02  (Xmitter or Value)
      IN02_QBAD { CFC_ForTest := 'true'} : Bool;   // QBad from AI Block
      IN02_QC : Byte := BYTE#16#00;   // Quality Code for Input 02
      IN02_TX { CFC_Visible := 'true'; CFC_Interconnectable := 'false'} : String := 'B';   // Text Input max 4 StringHas Assignable UnitsParameter to be translated to OSParameter to update auto in monitor
      IN03 { CFC_EngineeringUnit := '%'; CFC_ForTest := 'true'} : Real;   // Input 03  (Xmitter or Value)
      IN03_QBAD { CFC_ForTest := 'true'} : Bool;   // QBad from AI Block
      IN03_QC : Byte := BYTE#16#00;   // Quality Code for Input 03
      IN03_TX { CFC_Visible := 'true'; CFC_Interconnectable := 'false'} : String := 'C';   // Text Input max 4 String
   END_VAR

   VAR_OUTPUT 
      QSEL { CFC_ForTest := 'true'} : Real;   // Selected Output
      QSEL_QBAD { CFC_ForTest := 'true'} : Bool;   // Selected Output QBAD (BTA)
      QSEL_QC { CFC_ForTest := 'true'} : Byte;   // Selected Output Quality Code
      QHOLD { CFC_ForTest := 'true'} : Bool;   // Hold is active. (All QBAD or MISMATCH)
      QBAD01 { CFC_ForTest := 'true'} : Bool;   // Input 01 in QBAD Condition
      QBAD02 { CFC_ForTest := 'true'} : Bool;   // Input 02 in QBAD Condition
      QBAD03 { CFC_ForTest := 'true'} : Bool;   // Input 03 in QBAD Condition
      QERR_ALL { CFC_ForTest := 'true'} : Bool;   // Error on all configured inputs
      QERR_MM { CFC_ForTest := 'true'} : Bool;   // Mismatch Error between two inputs
      QWARN_EN { CFC_ForTest := 'true'} : Bool;   // Input Enable Warning (not all configd inputs enabled)
      QWARN_CFG { CFC_ForTest := 'true'} : Bool;   // Configuration Warning (possible configuration error)
      Q_LO { CFC_ForTest := 'true'} : Real;   // Low Value for display or connection elsewhere
      Q_HI { CFC_ForTest := 'true'} : Real;   // High Value for display or connection elsewhere
      Q_MID { CFC_ForTest := 'true'} : Real;   // Middle Value for display or connection elsewhere
      Q_AVG { CFC_ForTest := 'true'} : Real;   // Average Value for display or connection elsewhere
      QSEL01 { CFC_ForTest := 'true'} : Bool;   // IN01 Selected as OUT
      QSEL02 { CFC_ForTest := 'true'} : Bool;   // IN02 Selected as OUT
      QSEL03 { CFC_ForTest := 'true'} : Bool;   // IN03 Selected as OUT
      QMODE_TXT { CFC_ForTest := 'true'} : String[3];   // Configured Mode in Text Format for OS
      Q_ANI { CFC_ForTest := 'true'} : Int;   // Animation Display
   END_VAR

   VAR_IN_OUT 
      NUM_IN { CFC_ForTest := 'true'} : Int := 2;   // Num of Inputs (1=Single,2=Dual,3=Triple)
      MODE { CFC_ForTest := 'true'} : Int := 0;   // Select Mode (0=Lo,1=Hi,2=Mid,3=Avg)
      MODE2 { CFC_ForTest := 'true'} : Int := 0;   // New Mode on QBAD if NUM_IN=3 (0=Lo,1=Hi,2=Mid,3=Avg)
      AR_EN { CFC_ForTest := 'true'} : Bool := 1;   // AutoRecover from BTA (0=No AutoRecover,1=AutoRecover)
      AR_DLY : Int := 5;   // Seconds to wait before AutoRecover
      IN01_REQ { CFC_ForTest := 'true'} : Bool := 1;   // Input 01 Enable Request
      IN02_REQ { CFC_ForTest := 'true'} : Bool := 0;   // Input 02 Enable Request
      IN03_REQ { CFC_ForTest := 'true'} : Bool := 0;   // Input 03 Enable Request
      HRANGE { CFC_ForTest := 'true'} : Real := 100.0;   // High Range for calculating DB_SP and MM_SP
      LRANGE { CFC_ForTest := 'true'} : Real := 0.0;   // Low Range for calculating DB_SP and MM_SP
      DB_PCNT { CFC_ForTest := 'true'} : Real := 0.5;   // Deadband Percent (percent of full range for deadband)
      MM_EN : Bool := 1;   // Mismatch Alarm Enable (0=Mismatch Off,1=Mismatch On)
      MM_PCNT { CFC_ForTest := 'true'} : Real := 4.0;   // Mismatch Percent (percent of full range for mismatch)
      MM_DLY : Int := 10;   // Seconds to wait for Mismatch Alarm
      MM_TMR_CURR : Real := 1.0;   // Mismatch Timer Current Value (sec)
      MM_TMR_PSET : Real := 1.0;   // Mismatch Timer Preset Value (sec)
      AR01_TMRC : Real := 1.0;   // AutoRecover 01 Timer Current Value (sec)
      AR02_TMRC : Real := 1.0;   // AutoRecover 02 Timer Current Value (sec)
      AR03_TMRC : Real := 1.0;   // AutoRecover 03 Timer Current Value (sec)
      AR_TMR_PSET : Real := 1.0;   // AutoRecover Timer Preset Value (sec)
      IN01_EN { CFC_ForTest := 'true'; CFC_Visible := 'false'} : Bool := 1;   // Input 01 Enable
      IN02_EN { CFC_ForTest := 'true'; CFC_Visible := 'false'} : Bool := 0;   // Input 02 Enable
      IN03_EN { CFC_ForTest := 'true'; CFC_Visible := 'false'} : Bool := 0;   // Input 03 Enable
      SCADA_DB : "INSELECTOR";   // SCADA Data block for InSelect
   END_VAR

   VAR 
      MM_SP : Real;   // Mismatch Setpoint (eng units between inputs to alarm)
      MM_TMR_RUN : Bool;   // Timer Run Command for Mismatch
      MM_TMR_DONE : Bool;   // Timer Done Status for Mismatch
      EXECTIME : Real;   // Execution Time (msec). Calculated from SAMPLE_T
      LAST_GOOD : Real;   // Last Good Output Value
      NUM_EN : Int;   // Number of Inputs Enabled
      IN01_EN_I : Int;   // Input 01 Enabled Integer format
      IN02_EN_I : Int;   // Input 02 Enabled Integer format
      IN03_EN_I : Int;   // Input 03 Enabled Integer format
      MODE2ACTIVE : Bool;   // Mode 2 is active (QBAD with NUM_IN=3)
      MODE_TEMP : Int;   // Mode Temp used when MODE2 is active.
      DB_EN : Bool := 1;   // Deadband Enable (0=Deadband Off,1=Deadband On)
      AR01_STRT : Bool;   // Timer Start Command for Auto Recovery 01
      AR02_STRT : Bool;   // Timer Start Command for Auto Recovery 02
      AR03_STRT : Bool;   // Timer Start Command for Auto Recovery 03
      AR01_TMRDN : Bool;   // Timer Done Status for Auto Recovery 01
      AR02_TMRDN : Bool;   // Timer Done Status for Auto Recovery 02
      AR03_TMRDN : Bool;   // Timer Done Status for Auto Recovery 03
      FLG01_QBAD : Bool;   // Flag on QBAD Condition for Input 01
      FLG02_QBAD : Bool;   // Flag on QBAD Condition for Input 02
      FLG03_QBAD : Bool;   // Flag on QBAD Condition for Input 03
      AR01_EN : Bool;   // AutoRecovery Enable of Input 01
      AR02_EN : Bool;   // AutoRecovery Enable of Input 02
      AR03_EN : Bool;   // AutoRecovery Enable of Input 03
      DB_SP : Real;   // Deadband Setpoint for Switching
      DB_SW_EN12 : Bool;   // Deadband Switching difference IN01 and IN02
      DB_SW_EN23 : Bool;   // Deadband Switching difference IN02 and IN03
      DB_SW_EN13 : Bool;   // Deadband Switching difference IN01 and IN03
      DB_SW_3L12 : Bool;   // Triple select LO; switch due to IN01 and IN02
      DB_SW_3L23 : Bool;   // Triple select LO; switch due to IN02 and IN03
      DB_SW_3L13 : Bool;   // Triple select LO; switch due to IN01 and IN03
      DB_SW_3LO : Bool;   // Deadband Switching difference for triple select LO
      DB_SW_3H12 : Bool;   // Triple select HI; switch due to IN01 and IN02
      DB_SW_3H23 : Bool;   // Triple select HI; switch due to IN02 and IN03
      DB_SW_3H13 : Bool;   // Triple select HI; switch due to IN01 and IN03
      DB_SW_3HI : Bool;   // Deadband Switching difference for triple select HI
      DB_SW_3M12 : Bool;   // Triple select MID; switch due to IN01 and IN02
      DB_SW_3M23 : Bool;   // Triple select MID; switch due to IN02 and IN03
      DB_SW_3M13 : Bool;   // Triple select MID; switch due to IN01 and IN03
      DB_SW_3MID : Bool;   // Deadband Switching difference for triple select MID
      IN01High : Bool;   // IN01 is highest
      IN02High : Bool;   // IN02 is highest
      IN03High : Bool;   // IN03 is highest
      IN01Higher : Bool;   // IN01 is higher than one of the others by DB_SP
      IN02Higher : Bool;   // IN02 is higher than one of the others by DB_SP
      IN03Higher : Bool;   // IN03 is higher than one of the others by DB_SP
      IN01Low : Bool;   // IN01 is lowest
      IN02Low : Bool;   // IN02 is lowest
      IN03Low : Bool;   // IN03 is lowest
      IN01Lower : Bool;   // IN01 is lower than one of the others by DB_SP
      IN02Lower : Bool;   // IN02 is lower than one of the others by DB_SP
      IN03Lower : Bool;   // IN03 is lower than one of the others by DB_SP
      QWARN_EN_LS : Bool;   // Condition of QWARN_EN during last (previous) scan
      QWARN_EN_OS : Bool;   // QWARN_EN One Shot to set re-evaluation if within DB
      L_IN01_REQ : Bool;   // Last IN01 value from SCADA
      L_IN02_REQ : Bool;   // Last IN02 value from SCADA
      L_IN03_REQ : Bool;   // Last IN03 value from SCADA
      L_MODE : Int;   // Last MODE value from SCADA
   END_VAR

   VAR_TEMP 
      IN01Temp : Real;   // Temporary Value of IN01 used within the block
      IN02Temp : Real;   // Temporary Value of IN02 used within the block
      IN03Temp : Real;   // Temporary Value of IN03 used within the block
      BCD_EN_B0 : Int;   // Bit 0 of BCD EN Code
      BCD_EN_B1 : Int;   // Bit 1 of BCD EN Code
      BCD_EN_B2 : Int;   // Bit 2 of BCD EN Code
      BCD_EN : Int;   // BCD Code of EN Bits
      MM_Err1 : Bool;   // Mismatch Error (Between IN01 and IN02)
      MM_Err2 : Bool;   // Mismatch Error (Between IN02 and IN03)
      MM_Err3 : Bool;   // Mismatch Error (Between IN03 and IN01)
      Dummy : Int;   // Return Value for the RD_SINFO SFC6 call
   END_VAR


BEGIN
	
	#MM_SP := (#MM_PCNT * (#HRANGE - #LRANGE)) / 100.0;
	#DB_SP := (#DB_PCNT * (#HRANGE - #LRANGE)) / 100.0;
	
	
	IF #IN01_QBAD THEN
	    #IN01_EN := false;
	    #IN01_REQ := false;
	    #FLG01_QBAD := true;
	END_IF;
	IF #IN02_QBAD OR (#NUM_IN < 2) THEN
	    #IN02_EN := false;
	    #IN02_REQ := false;
	    #FLG02_QBAD := true;
	END_IF;
	IF #IN03_QBAD OR (#NUM_IN < 3) THEN
	    #IN03_EN := false;
	    #IN03_REQ := false;
	    #FLG03_QBAD := true;
	END_IF;
	
	
	
	
	IF #IN01_EN AND NOT (#IN01_QBAD) THEN
	    #FLG01_QBAD := FALSE;
	END_IF;
	IF #IN02_EN AND NOT (#IN02_QBAD) THEN
	    #FLG02_QBAD := FALSE;
	END_IF;
	IF #IN03_EN AND NOT (#IN03_QBAD) THEN
	    #FLG03_QBAD := FALSE;
	END_IF;
	
	
	IF #AR_EN THEN
	    IF NOT (#IN01_EN) AND NOT (#IN01_QBAD) AND #AR01_EN THEN
	        #IN01_REQ := TRUE;
	    END_IF;
	    IF NOT (#IN02_EN) AND NOT (#IN02_QBAD) AND #AR02_EN THEN
	        #IN02_REQ := TRUE;
	    END_IF;
	    IF NOT (#IN03_EN) AND NOT (#IN03_QBAD) AND #AR03_EN THEN
	        #IN03_REQ := TRUE;
	    END_IF;
	END_IF;
	
	
	
	#QWARN_EN_OS := false;
	IF #QWARN_EN AND NOT (#QWARN_EN_LS) THEN
	    #QWARN_EN_OS := true;
	END_IF;
	#QWARN_EN_LS := #QWARN_EN;
	
	
	
	// Part 1: Differences between each pair outside of DB_SP.
	#DB_SW_EN12 := (ABS(#IN01 - #IN02) > #DB_SP) OR #QWARN_EN_OS;
	#DB_SW_EN23 := (ABS(#IN02 - #IN03) > #DB_SP) OR #QWARN_EN_OS;
	#DB_SW_EN13 := (ABS(#IN01 - #IN03) > #DB_SP) OR #QWARN_EN_OS;
	
	// Part 2: Calculate Low, High, Lower and Higher.
	#IN01Low := (((#IN01 <= #IN02) AND (#IN01 < #IN03)) OR ((#IN01 <= #IN03) AND (#IN01 < #IN02)));
	#IN02Low := (((#IN02 <= #IN01) AND (#IN02 < #IN03)) OR ((#IN02 <= #IN03) AND (#IN02 < #IN01)));
	#IN03Low := (((#IN03 <= #IN01) AND (#IN03 < #IN02)) OR ((#IN03 <= #IN02) AND (#IN03 < #IN01)));
	#IN01Lower := (((#IN02 - #IN01) > #DB_SP) OR ((#IN03 - #IN01) > #DB_SP));
	#IN02Lower := (((#IN01 - #IN02) > #DB_SP) OR ((#IN03 - #IN02) > #DB_SP));
	#IN03Lower := (((#IN01 - #IN03) > #DB_SP) OR ((#IN02 - #IN03) > #DB_SP));
	
	#IN01High := (((#IN01 >= #IN02) AND (#IN01 > #IN03)) OR ((#IN01 >= #IN03) AND (#IN01 > #IN02)));
	#IN02High := (((#IN02 >= #IN01) AND (#IN02 > #IN03)) OR ((#IN02 >= #IN03) AND (#IN02 > #IN01)));
	#IN03High := (((#IN03 >= #IN01) AND (#IN03 > #IN02)) OR ((#IN03 >= #IN02) AND (#IN03 > #IN01)));
	#IN01Higher := (((#IN01 - #IN02) > #DB_SP) OR ((#IN01 - #IN03) > #DB_SP));
	#IN02Higher := (((#IN02 - #IN01) > #DB_SP) OR ((#IN02 - #IN03) > #DB_SP));
	#IN03Higher := (((#IN03 - #IN01) > #DB_SP) OR ((#IN03 - #IN02) > #DB_SP));
	
	// Part 3: Check for a new calculation required for triple select LO.
	#DB_SW_3L12 := (#IN03High AND #DB_SW_EN12) OR (#IN03High AND #IN03Higher AND #QSEL03);
	#DB_SW_3L23 := (#IN01High AND #DB_SW_EN23) OR (#IN01High AND #IN01Higher AND #QSEL01);
	#DB_SW_3L13 := (#IN02High AND #DB_SW_EN13) OR (#IN02High AND #IN02Higher AND #QSEL02);
	#DB_SW_3LO := #DB_SW_3L12 OR #DB_SW_3L23 OR #DB_SW_3L13;
	
	// Part 4: Check for a new calculation required for triple select HI.
	#DB_SW_3H12 := (#IN03Low AND #DB_SW_EN12) OR (#IN03Low AND #IN03Lower AND #QSEL03);
	#DB_SW_3H23 := (#IN01Low AND #DB_SW_EN23) OR (#IN01Low AND #IN01Lower AND #QSEL01);
	#DB_SW_3H13 := (#IN02Low AND #DB_SW_EN13) OR (#IN02Low AND #IN02Lower AND #QSEL02);
	#DB_SW_3HI := #DB_SW_3H12 OR #DB_SW_3H23 OR #DB_SW_3H13;
	
	// Part 5: Check for a new calculation required for triple select MID.
	#DB_SW_3M12 := ((#IN03High OR #IN03Low) AND #DB_SW_EN12) OR (#IN03Low AND #IN03Lower AND #QSEL03) OR (#IN03High AND #IN03Higher AND #QSEL03);
	#DB_SW_3M23 := ((#IN01High OR #IN01Low) AND #DB_SW_EN23) OR (#IN01Low AND #IN01Lower AND #QSEL01) OR (#IN01High AND #IN01Higher AND #QSEL01);
	#DB_SW_3M13 := ((#IN02High OR #IN02Low) AND #DB_SW_EN13) OR (#IN02Low AND #IN02Lower AND #QSEL02) OR (#IN02High AND #IN02Higher AND #QSEL02);
	#DB_SW_3MID := #DB_SW_3M12 OR #DB_SW_3M23 OR #DB_SW_3M13;
	
	
	
	// Part 1: Determine if MODE2 needs to be activated.
	#MODE2ACTIVE := (#NUM_IN = 3) AND (#IN01_QBAD OR #IN02_QBAD OR #IN03_QBAD OR #QWARN_EN);
	
	// Part 2: Set the QBAD outputs based on QBAD inputs.
	#QBAD01 := #IN01_QBAD;
	#QBAD02 := #IN02_QBAD;
	#QBAD03 := #IN03_QBAD;
	
	
	
	#QWARN_CFG := ((#NUM_IN = 1) AND ((#IN02 <> 0.0) OR (#IN03 <> 0.0))) OR
	((#NUM_IN = 2) AND (#IN03 <> 0.0));
	
	
	
	#IN01Temp := #IN01;
	#IN02Temp := #IN02;
	#IN03Temp := #IN03;
	
	
	// Set up a BCD code from the INnn_EN bits to use in this block.
	IF #IN01_EN THEN
	    #BCD_EN_B0 := 1;
	ELSE
	    #BCD_EN_B0 := 0;
	END_IF;
	IF #IN02_EN THEN
	    #BCD_EN_B1 := 2;
	ELSE
	    #BCD_EN_B1 := 0;
	END_IF;
	IF #IN03_EN THEN
	    #BCD_EN_B2 := 4;
	ELSE
	    #BCD_EN_B2 := 0;
	END_IF;
	#BCD_EN := #BCD_EN_B0 + #BCD_EN_B1 + #BCD_EN_B2;
	
	
	
	// Part 1: Range Limit the NUM_IN to 1, 2, or 3.
	IF #NUM_IN < 1 THEN
	    #NUM_IN := 1;
	END_IF;
	IF #NUM_IN > 3 THEN
	    #NUM_IN := 3;
	END_IF;
	
	// Part 2: Range Limit MODE between 0 and 3.
	IF #MODE < 0 THEN
	    #MODE := 0;
	END_IF;
	IF #MODE > 3 THEN
	    #MODE := 3;
	END_IF;
	
	// Part 3: Range Limit MODE2 between 0 and 3.
	IF #MODE2 < 0 THEN
	    #MODE2 := 0;
	END_IF;
	IF #MODE2 > 3 THEN
	    #MODE2 := 3;
	END_IF;
	
	
	
	// Part 1: Set the ERR_ALL if all inputs are in QBAD condition.
	// Used the IN0n_EN to prevent clearing ERR_ALL until input is enabled by operator again.
	#QERR_ALL := NOT (#IN01_EN) AND NOT (#IN02_EN) AND NOT (#IN03_EN);
	
	// Part 2: Set the QWARN_EN output if there is an input that is disabled.
	// First, determine number of inputs enabled, then compare and send warning.
	// Originally (until version 1.1) this QWARN_EN was filtered to not come true if a QBAD condition existed.
	// However, client requests this warning to be true also on QBAD conditions.  Good code saved, client code
	// implemented (see below).
	IF #IN01_EN THEN
	    #IN01_EN_I := 1;
	ELSE
	    #IN01_EN_I := 0;
	END_IF;
	IF #IN02_EN THEN
	    #IN02_EN_I := 1;
	ELSE
	    #IN02_EN_I := 0;
	END_IF;
	IF #IN03_EN THEN
	    #IN03_EN_I := 1;
	ELSE
	    #IN03_EN_I := 0;
	END_IF;
	#NUM_EN := #IN01_EN_I + #IN02_EN_I + #IN03_EN_I;
	#QWARN_EN := (#NUM_IN <> #NUM_EN);
	// Good code saved here.
	//QWARN_EN  := ((NUM_IN <> NUM_EN) AND NOT(QERR_ALL) AND NOT(IN01_QBAD) AND NOT(IN02_QBAD) AND NOT(IN03_QBAD));
	
	
	
	// Input Enable Request Management
	IF NOT ((#NUM_EN = 1) AND (#IN01_EN)) THEN
	    #IN01_EN := #IN01_REQ;
	END_IF;
	IF NOT ((#NUM_EN = 1) AND (#IN02_EN)) THEN
	    #IN02_EN := #IN02_REQ;
	END_IF;
	IF NOT ((#NUM_EN = 1) AND (#IN03_EN)) THEN
	    #IN03_EN := #IN03_REQ;
	END_IF;
	
	// Write back the EN to the REQ bit to keep it in sync.
	#IN01_REQ := #IN01_EN;
	#IN02_REQ := #IN02_EN;
	#IN03_REQ := #IN03_EN;
	
	
	// Set up all outputs based on the BCD_EN code.
	CASE #BCD_EN OF
	        // If none are enabled, display none selected.
	        // This case could be generated from all QBAD or operator tried to deselect all.
	    0:
	        #QSEL01 := false;
	        #QSEL02 := false;
	        #QSEL03 := false;
	        
	        // If only IN01_EN is active, set IN01 as the output.
	        // Report which output is selected.
	    1:
	        #Q_LO := #IN01Temp;
	        #Q_HI := #IN01Temp;
	        #Q_MID := #IN01Temp;
	        #Q_AVG := #IN01Temp;
	        #QSEL01 := true;
	        #QSEL02 := false;
	        #QSEL03 := false;
	        
	        // If only IN02_EN is active, set IN02 as the output.
	        // Report which output is selected.
	    2:
	        #Q_LO := #IN02Temp;
	        #Q_HI := #IN02Temp;
	        #Q_MID := #IN02Temp;
	        #Q_AVG := #IN02Temp;
	        #QSEL01 := false;
	        #QSEL02 := true;
	        #QSEL03 := false;
	        
	        // If IN01_EN and IN02_EN are active, compare the values for sending out.
	        // Report which output is selected.
	    3:
	        // Set up MODE2 if required.
	        IF #MODE2ACTIVE THEN
	            #MODE_TEMP := #MODE2;
	        ELSE
	            #MODE_TEMP := #MODE;
	        END_IF;
	        // Find the lower of the two values and put in the Q_LO location.
	        // If Deadband Switching is Enabled (default), then check to see if the
	        // values need to be switched first.  If not, send the new input value
	        // of the same transmitter to the output.  If so, calculate the switch.
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_EN12 THEN                     // No switching of inputs required
	                IF #QSEL01 THEN                         // Keep the same input sent to output
	                    #Q_LO := #IN01Temp;
	                ELSE
	                    #Q_LO := #IN02Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN01Temp < #IN02Temp THEN            // IN01 is low
	                    #Q_LO := #IN01Temp;
	                    IF #MODE_TEMP = 0 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN02 is low
	                    #Q_LO := #IN02Temp;
	                    IF #MODE_TEMP = 0 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := true;
	                        #QSEL03 := false;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN01Temp < #IN02Temp THEN                // IN01 is low
	                #Q_LO := #IN01Temp;
	                IF #MODE_TEMP = 0 THEN
	                    #QSEL01 := true;
	                    #QSEL02 := false;
	                    #QSEL03 := false;
	                END_IF;
	            ELSE                                        // IN02 is low
	                #Q_LO := #IN02Temp;
	                IF #MODE_TEMP = 0 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := true;
	                    #QSEL03 := false;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	        // Find the higher of the two values and put in the Q_HI location.
	        // If Deadband Switching is Enabled (default), then check to see if the
	        // values need to be switched first.  If not, send the new input value
	        // of the same transmitter to the output.  If so, calculate the switch.
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_EN12 THEN                     // No switching of inputs required
	                IF #QSEL01 THEN                         // Keep the same input sent to output
	                    #Q_HI := #IN01Temp;
	                ELSE
	                    #Q_HI := #IN02Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN01Temp > #IN02Temp THEN            // IN01 is high
	                    #Q_HI := #IN01Temp;
	                    IF #MODE_TEMP = 1 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN02 is high
	                    #Q_HI := #IN02Temp;
	                    IF #MODE_TEMP = 1 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := true;
	                        #QSEL03 := false;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN01Temp > #IN02Temp THEN                // IN01 is high
	                #Q_HI := #IN01Temp;
	                IF #MODE_TEMP = 1 THEN
	                    #QSEL01 := true;
	                    #QSEL02 := false;
	                    #QSEL03 := false;
	                END_IF;
	            ELSE                                        // IN02 is high
	                #Q_HI := #IN02Temp;
	                IF #MODE_TEMP = 1 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := true;
	                    #QSEL03 := false;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	        // Find the MID (same as average) and put in the Q_MID and Q_AVG.
	        #Q_MID := (#IN01Temp + #IN02Temp) / 2.0;
	        #Q_AVG := #Q_MID;
	        IF (#MODE_TEMP = 2) OR (#MODE_TEMP = 3) THEN
	            #QSEL01 := true;
	            #QSEL02 := true;
	            #QSEL03 := false;
	        END_IF;
	        
	        // If only IN03_EN is active, send out the Manual or Auto value from IN03.
	        // Report which output is selected.
	    4:
	        #Q_LO := #IN03Temp;
	        #Q_HI := #IN03Temp;
	        #Q_MID := #IN03Temp;
	        #Q_AVG := #IN03Temp;
	        #QSEL01 := false;
	        #QSEL02 := false;
	        #QSEL03 := true;
	        
	        // If IN01_EN and IN03_EN are active, compare the values for sending out.
	        // Report which output is selected.
	    5:
	        // Set up MODE2 if required.
	        IF #MODE2ACTIVE THEN
	            #MODE_TEMP := #MODE2;
	        ELSE
	            #MODE_TEMP := #MODE;
	        END_IF;
	        // Find the lower of the two values and put in the Q_LO location.
	        // If Deadband Switching is Enabled (default), then check to see if the
	        // values need to be switched first.  If not, send the new input value
	        // of the same transmitter to the output.  If so, calculate the switch.
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_EN13 THEN                     // No switching of inputs required
	                IF #QSEL01 THEN                         // Keep the same input sent to output
	                    #Q_LO := #IN01Temp;
	                ELSE
	                    #Q_LO := #IN03Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN01Temp < #IN03Temp THEN            // IN01 is low
	                    #Q_LO := #IN01Temp;
	                    IF #MODE_TEMP = 0 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is low
	                    #Q_LO := #IN03Temp;
	                    IF #MODE_TEMP = 0 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN01Temp < #IN03Temp THEN                // IN01 is low
	                #Q_LO := #IN01Temp;
	                IF #MODE_TEMP = 0 THEN
	                    #QSEL01 := true;
	                    #QSEL02 := false;
	                    #QSEL03 := false;
	                END_IF;
	            ELSE                                        // IN03 is low
	                #Q_LO := #IN03Temp;
	                IF #MODE_TEMP = 0 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := false;
	                    #QSEL03 := true;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	        // Find the higher of the two values and put in the Q_HI location.
	        // If Deadband Switching is Enabled (default), then check to see if the
	        // values need to be switched first.  If not, send the new input value
	        // of the same transmitter to the output.  If so, calculate the switch.
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_EN13 THEN                     // No switching of inputs required
	                IF #QSEL01 THEN                         // Keep the same input sent to output
	                    #Q_HI := #IN01Temp;
	                ELSE
	                    #Q_HI := #IN03Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN01Temp > #IN03Temp THEN            // IN01 is high
	                    #Q_HI := #IN01Temp;
	                    IF #MODE_TEMP = 1 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is high
	                    #Q_HI := #IN03Temp;
	                    IF #MODE_TEMP = 1 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN01Temp > #IN03Temp THEN                // IN01 is high
	                #Q_HI := #IN01Temp;
	                IF #MODE_TEMP = 1 THEN
	                    #QSEL01 := true;
	                    #QSEL02 := false;
	                    #QSEL03 := false;
	                END_IF;
	            ELSE                                        // IN03 is high
	                #Q_HI := #IN03Temp;
	                IF #MODE_TEMP = 1 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := false;
	                    #QSEL03 := true;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN

	        #Q_MID := (#IN01Temp + #IN03Temp) / 2.0;
	        #Q_AVG := #Q_MID;
	        IF (#MODE_TEMP = 2) OR (#MODE_TEMP = 3) THEN
	            #QSEL01 := true;
	            #QSEL02 := false;
	            #QSEL03 := true;
	        END_IF;
	        

	    6:
	        
	        IF #MODE2ACTIVE THEN
	            #MODE_TEMP := #MODE2;
	        ELSE
	            #MODE_TEMP := #MODE;
	        END_IF;
	       
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_EN23 THEN                     // No switching of inputs required
	                IF #QSEL02 THEN                         // Keep the same input sent to output
	                    #Q_LO := #IN02Temp;
	                ELSE
	                    #Q_LO := #IN03Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN02Temp < #IN03Temp THEN            // IN02 is low
	                    #Q_LO := #IN02Temp;
	                    IF #MODE_TEMP = 0 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := true;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is low
	                    #Q_LO := #IN03Temp;
	                    IF #MODE_TEMP = 0 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN02Temp < #IN03Temp THEN                // IN02 is low
	                #Q_LO := #IN02Temp;
	                IF #MODE_TEMP = 0 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := true;
	                    #QSEL03 := false;
	                END_IF;
	            ELSE                                        // IN03 is low
	                #Q_LO := #IN03Temp;
	                IF #MODE_TEMP = 0 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := false;
	                    #QSEL03 := true;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	        // Find the higher of the two values and put in the Q_HI location.
	        // If Deadband Switching is Enabled (default), then check to see if the
	        // values need to be switched first.  If not, send the new input value
	        // of the same transmitter to the output.  If so, calculate the switch.
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_EN23 THEN                     // No switching of inputs required
	                IF #QSEL02 THEN                         // Keep the same input sent to output
	                    #Q_HI := #IN02Temp;
	                ELSE
	                    #Q_HI := #IN03Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN02Temp > #IN03Temp THEN            // IN02 is high
	                    #Q_HI := #IN02Temp;
	                    IF #MODE_TEMP = 1 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := true;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is high
	                    #Q_HI := #IN03Temp;
	                    IF #MODE_TEMP = 1 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN02Temp > #IN03Temp THEN                // IN02 is high
	                #Q_HI := #IN02Temp;
	                IF #MODE_TEMP = 1 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := true;
	                    #QSEL03 := false;
	                END_IF;
	            ELSE                                        // IN03 is high
	                #Q_HI := #IN03Temp;
	                IF #MODE_TEMP = 1 THEN
	                    #QSEL01 := false;
	                    #QSEL02 := false;
	                    #QSEL03 := true;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	        // Find the MID (same as average) and put in the Q_MID and Q_AVG.
	        #Q_MID := (#IN02Temp + #IN03Temp) / 2.0;
	        #Q_AVG := #Q_MID;
	        IF (#MODE_TEMP = 2) OR (#MODE_TEMP = 3) THEN
	            #QSEL01 := false;
	            #QSEL02 := true;
	            #QSEL03 := true;
	        END_IF;
	        
	     
	    7:
	       
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_3LO THEN                      // No switching of inputs required
	                IF #QSEL01 THEN                         // Keep the same input sent to output
	                    #Q_LO := #IN01Temp;
	                END_IF;
	                IF #QSEL02 THEN
	                    #Q_LO := #IN02Temp;
	                END_IF;
	                IF #QSEL03 THEN
	                    #Q_LO := #IN03Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN01Temp <= #IN02Temp THEN           // IN01 is lower than IN02
	                    IF #IN01Temp < #IN03Temp THEN        // IN01 is lowest, IN03 lower than IN02
	                        #Q_LO := #IN01Temp;
	                        IF #MODE = 0 THEN
	                            #QSEL01 := true;
	                            #QSEL02 := false;
	                            #QSEL03 := false;
	                        END_IF;
	                    ELSE                                // IN03 is lowest
	                        #Q_LO := #IN03Temp;
	                        IF #MODE = 0 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := false;
	                            #QSEL03 := true;
	                        END_IF;
	                    END_IF;
	                ELSE                                    // IN01 is not lower than IN02
	                    IF #IN02Temp <= #IN03Temp THEN       // IN02 is lowest
	                        #Q_LO := #IN02Temp;
	                        IF #MODE = 0 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := true;
	                            #QSEL03 := false;
	                        END_IF;
	                    ELSE                                // IN03 is lowest
	                        #Q_LO := #IN03Temp;
	                        IF #MODE = 0 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := false;
	                            #QSEL03 := true;
	                        END_IF;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN01Temp <= #IN02Temp THEN               // IN01 is lower than IN02
	                IF #IN01Temp < #IN03Temp THEN            // IN01 is lowest, IN03 lower than IN02
	                    #Q_LO := #IN01Temp;
	                    IF #MODE = 0 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is lowest
	                    #Q_LO := #IN03Temp;
	                    IF #MODE = 0 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            ELSE                                        // IN01 is not lower than IN02
	                IF #IN02Temp <= #IN03Temp THEN           // IN02 is lowest
	                    #Q_LO := #IN02Temp;
	                    IF #MODE = 0 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := true;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is lowest
	                    #Q_LO := #IN03Temp;
	                    IF #MODE = 0 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	        
	        // Find the highest of the three values and put in the Q_HI location.
	        // If Deadband Switching is Enabled (default), then check to see if the
	        // values need to be switched first.  If not, send the new input value
	        // of the same transmitter to the output.  If so, calculate the switch.
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_3HI THEN                      // No switching of inputs required
	                IF #QSEL01 THEN                         // Keep the same input sent to output
	                    #Q_HI := #IN01Temp;
	                END_IF;
	                IF #QSEL02 THEN
	                    #Q_HI := #IN02Temp;
	                END_IF;
	                IF #QSEL03 THEN
	                    #Q_HI := #IN03Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN01Temp >= #IN02Temp THEN           // IN01 is higher than IN02
	                    IF #IN01Temp > #IN03Temp THEN        // IN01 is highest
	                        #Q_HI := #IN01Temp;
	                        IF #MODE = 1 THEN
	                            #QSEL01 := true;
	                            #QSEL02 := false;
	                            #QSEL03 := false;
	                        END_IF;
	                    ELSE                                // IN03 is highest
	                        #Q_HI := #IN03Temp;
	                        IF #MODE = 1 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := false;
	                            #QSEL03 := true;
	                        END_IF;
	                    END_IF;
	                ELSE                                    // IN01 is not higher than IN02
	                    IF #IN02Temp >= #IN03Temp THEN       // IN02 is highest
	                        #Q_HI := #IN02Temp;
	                        IF #MODE = 1 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := true;
	                            #QSEL03 := false;
	                        END_IF;
	                    ELSE                                // IN03 is highest
	                        #Q_HI := #IN03Temp;
	                        IF #MODE = 1 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := false;
	                            #QSEL03 := true;
	                        END_IF;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN01Temp >= #IN02Temp THEN               // IN01 is higher than IN02
	                IF #IN01Temp > #IN03Temp THEN            // IN01 is highest
	                    #Q_HI := #IN01Temp;
	                    IF #MODE = 1 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is highest
	                    #Q_HI := #IN03Temp;
	                    IF #MODE = 1 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            ELSE                                        // IN01 is not higher than IN02
	                IF #IN02Temp >= #IN03Temp THEN           // IN02 is highest
	                    #Q_HI := #IN02Temp;
	                    IF #MODE = 1 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := true;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN03 is highest
	                    #Q_HI := #IN03Temp;
	                    IF #MODE = 1 THEN
	                        #QSEL01 := false;
	                        #QSEL02 := false;
	                        #QSEL03 := true;
	                    END_IF;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	  
	        IF #DB_EN THEN                                  // Deadband switching is enabled
	            IF NOT #DB_SW_3MID THEN                     // No switching of inputs required
	                IF #QSEL01 THEN                         // Keep the same input sent to output
	                    #Q_MID := #IN01Temp;
	                END_IF;
	                IF #QSEL02 THEN
	                    #Q_MID := #IN02Temp;
	                END_IF;
	                IF #QSEL03 THEN
	                    #Q_MID := #IN03Temp;
	                END_IF;
	            ELSE                                        // Input switching is required
	                IF #IN01Temp >= #IN02Temp THEN           // IN01 is greater than or equal to IN02, 213
	                    IF #IN01Temp < #IN03Temp THEN        // IN01 is less than IN03, IN01 is middle
	                        #Q_MID := #IN01Temp;
	                        IF #MODE = 2 THEN
	                            #QSEL01 := true;
	                            #QSEL02 := false;
	                            #QSEL03 := false;
	                        END_IF;
	                    ELSE                                // IN02 or IN03 is middle
	                        IF #IN02Temp <= #IN03Temp THEN   // IN03 is middle
	                            #Q_MID := #IN03Temp;
	                            IF #MODE = 2 THEN
	                                #QSEL01 := false;
	                                #QSEL02 := false;
	                                #QSEL03 := true;
	                            END_IF;
	                        ELSE                            // IN02 is middle
	                            #Q_MID := #IN02Temp;
	                            IF #MODE = 2 THEN
	                                #QSEL01 := false;
	                                #QSEL02 := true;
	                                #QSEL03 := false;
	                            END_IF;
	                        END_IF;
	                    END_IF;
	                ELSE
	                    IF #IN01Temp >= #IN03Temp THEN       // IN01 is greater than or equal to IN03
	                        #Q_MID := #IN01Temp;              // IN01 is middle
	                        IF #MODE = 2 THEN
	                            #QSEL01 := true;
	                            #QSEL02 := false;
	                            #QSEL03 := false;
	                        END_IF;
	                    ELSE                                // IN01 is less than IN03
	                        IF #IN02Temp >= #IN03Temp THEN   // IN02 is greater than or equal to IN03
	                            #Q_MID := #IN03Temp;          // IN03 is middle
	                            IF #MODE = 2 THEN
	                                #QSEL01 := false;
	                                #QSEL02 := false;
	                                #QSEL03 := true;
	                            END_IF;
	                        ELSE                            // IN02 is middle
	                            #Q_MID := #IN02Temp;
	                            IF #MODE = 2 THEN
	                                #QSEL01 := false;
	                                #QSEL02 := true;
	                                #QSEL03 := false;
	                            END_IF;
	                        END_IF;
	                    END_IF;
	                END_IF;
	            END_IF;
	        ELSE                                            // DB_EN is not selected, switch regardless
	            IF #IN01Temp >= #IN02Temp THEN               // IN01 will be middle if it is less than IN03
	                IF #IN01Temp < #IN03Temp THEN            // IN01 is middle
	                    #Q_MID := #IN01Temp;
	                    IF #MODE = 2 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE                                    // IN01 cannot be middle
	                    IF #IN02Temp <= #IN03Temp THEN       // IN03 is middle
	                        #Q_MID := #IN03Temp;
	                        IF #MODE = 2 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := false;
	                            #QSEL03 := true;
	                        END_IF;
	                    ELSE                                // IN02 is middle
	                        #Q_MID := #IN02Temp;
	                        IF #MODE = 2 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := true;
	                            #QSEL03 := false;
	                        END_IF;
	                    END_IF;
	                END_IF;
	            ELSE
	                IF #IN01Temp >= #IN03Temp THEN           // IN01 is middle
	                    #Q_MID := #IN01Temp;
	                    IF #MODE = 2 THEN
	                        #QSEL01 := true;
	                        #QSEL02 := false;
	                        #QSEL03 := false;
	                    END_IF;
	                ELSE
	                    IF #IN02Temp >= #IN03Temp THEN       // IN03 is middle
	                        #Q_MID := #IN03Temp;
	                        IF #MODE = 2 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := false;
	                            #QSEL03 := true;
	                        END_IF;
	                    ELSE                                // IN02 is middle
	                        #Q_MID := #IN02Temp;
	                        IF #MODE = 2 THEN
	                            #QSEL01 := false;
	                            #QSEL02 := true;
	                            #QSEL03 := false;
	                        END_IF;
	                    END_IF;
	                END_IF;
	            END_IF;
	        END_IF;                                         // End of DB_EN
	        // Find the average of the three values and put in the Q_AVG location.
	        #Q_AVG := (#IN01Temp + #IN02Temp + #IN03Temp) / 3.0;
	        IF #MODE = 3 THEN
	            #QSEL01 := true;
	            #QSEL02 := true;
	            #QSEL03 := true;
	        END_IF;
	END_CASE;
	
	
	IF #MODE2ACTIVE THEN
	    CASE #MODE_TEMP OF
	            // Set the output based on the MODE selected (Lo, Hi, Mid, or Average)
	            // Set the QMODE_TXT string for the OS.
	        0:
	            #QSEL := #Q_LO;
	            #QMODE_TXT := 'LO';
	        1:
	            #QSEL := #Q_HI;
	            #QMODE_TXT := 'HI';
	        2:
	            #QSEL := #Q_MID;
	            #QMODE_TXT := 'AVG';               //MID acts as AVG, so display AVG
	        3:
	            #QSEL := #Q_AVG;
	            #QMODE_TXT := 'AVG';
	    END_CASE;
	ELSE
	    CASE #MODE OF
	            // Set the output based on the MODE selected (Lo, Hi, Mid, or Average)
	            // Set the QMODE_TXT string for the OS.
	        0:
	            #QSEL := #Q_LO;
	            #QMODE_TXT := 'LO';
	        1:
	            #QSEL := #Q_HI;
	            #QMODE_TXT := 'HI';
	        2:
	            #QSEL := #Q_MID;
	            IF #NUM_IN = 3 THEN                 //In case of NUM_IN <> 3, display AVG
	                #QMODE_TXT := 'MID';
	            ELSE
	                #QMODE_TXT := 'AVG';
	            END_IF;
	        3:
	            #QSEL := #Q_AVG;
	            #QMODE_TXT := 'AVG';
	    END_CASE;
	END_IF;
	

	// Part 1: Set Hold Logic
	IF #QHOLD THEN
	    #QSEL := #LAST_GOOD;
	ELSE
	    #LAST_GOOD := #QSEL;
	END_IF;
	
	
	// Part 1: Calculate if there is a mismatch.
	IF #MM_EN THEN
	    #MM_Err1 := ((ABS(#IN01 - #IN02) > #MM_SP) AND (#IN01_EN AND #IN02_EN));
	    #MM_Err2 := ((ABS(#IN02 - #IN03) > #MM_SP) AND (#IN02_EN AND #IN03_EN));
	    #MM_Err3 := ((ABS(#IN03 - #IN01) > #MM_SP) AND (#IN03_EN AND #IN01_EN));
	ELSE
	    #MM_Err1 := False;
	    #MM_Err2 := False;
	    #MM_Err3 := False;
	END_IF;
	
	// Part 2: If a mismatch condition exists for the MM_TIME seconds, set the ERR_MM output.
	IF (#MM_Err1 OR #MM_Err2 OR #MM_Err3) THEN
	    #MM_TMR_RUN := true;
	    IF #MM_TMR_DONE THEN
	        #QERR_MM := true;
	    END_IF;
	ELSE
	    #QERR_MM := false;
	    #MM_TMR_RUN := false;
	END_IF;
	
	// Part 3: Timer Code.
	// Set up the EXECTIME to work properly.
	// Translate the MM_DLY input (seconds) into the Preset for Timer (msec)
	#EXECTIME := #SAMPLE_T;
	#MM_TMR_PSET := INT_TO_REAL(#MM_DLY);
	IF NOT (#MM_TMR_RUN) THEN
	    #MM_TMR_CURR := 0;
	    #MM_TMR_DONE := FALSE;
	ELSE
	    IF (#MM_TMR_CURR <= #MM_TMR_PSET) THEN
	        #MM_TMR_CURR := #MM_TMR_CURR + #EXECTIME;
	    ELSE
	        #MM_TMR_DONE := (#MM_TMR_CURR >= #MM_TMR_PSET);
	    END_IF;
	END_IF;
	

	
	// Check for Conditions where AutoRecovery needs to be used.
	IF #AR_EN THEN
	    IF (NOT (#IN01_QBAD) AND #FLG01_QBAD) THEN
	        #AR01_STRT := TRUE;                          // This needs to be held true until timer is done.
	        IF #AR01_TMRDN THEN
	            #AR01_EN := TRUE;                        // IN01 Enable by Code (AutoRecovery). Clear where used.
	        END_IF;
	    ELSE
	        #AR01_STRT := FALSE;
	        #AR01_EN := FALSE;                           // Keep false here too so it will not auto enable.
	    END_IF;
	    
	    IF (NOT (#IN02_QBAD) AND #FLG02_QBAD AND (#NUM_IN > 1)) THEN
	        #AR02_STRT := TRUE;                          // This needs to be held true until timer is done.
	        IF #AR02_TMRDN THEN
	            #AR02_EN := TRUE;                        // IN02 Enable by Code (AutoRecovery). Clear where used.
	        END_IF;
	    ELSE
	        #AR02_STRT := FALSE;
	        #AR02_EN := FALSE;                           // Keep false here too so it will not auto enable.
	    END_IF;
	    
	    IF (NOT (#IN03_QBAD) AND #FLG03_QBAD AND (#NUM_IN > 2)) THEN
	        #AR03_STRT := TRUE;                          // This needs to be held true until timer is done.
	        IF #AR03_TMRDN THEN
	            #AR03_EN := TRUE;                        // IN03 Enable by Code (AutoRecovery). Clear where used.
	        END_IF;
	    ELSE
	        #AR03_STRT := FALSE;
	        #AR03_EN := FALSE;                           // Keep false here too so it will not auto enable.
	    END_IF;
	ELSE                                                // If Auto Recovery is not enabled, prevent or stop timers.
	    #AR01_STRT := FALSE;
	    #AR02_STRT := FALSE;
	    #AR03_STRT := FALSE;
	END_IF;
	
	
	// Timer Code for AutoRecovery Timer 01.
	// Note: Exectime has already been configured and used above with MM Timer.
	// Note: AR_TMR_PSET needs to only be set here once; used for all three timers.
	#AR_TMR_PSET := #AR_DLY;
	IF NOT (#AR01_STRT) THEN
	    #AR01_TMRC := 0;
	    #AR01_TMRDN := FALSE;
	ELSE
	    IF (#AR01_TMRC <= #AR_TMR_PSET) THEN
	        #AR01_TMRC := #AR01_TMRC + #EXECTIME;
	    ELSE
	        #AR01_TMRDN := (#AR01_TMRC >= #AR_TMR_PSET);
	    END_IF;
	END_IF;
	
	// Timer Code for AutoRecovery Timer 02.
	IF NOT (#AR02_STRT) THEN
	    #AR02_TMRC := 0;
	    #AR02_TMRDN := FALSE;
	ELSE
	    IF (#AR02_TMRC <= #AR_TMR_PSET) THEN
	        #AR02_TMRC := #AR02_TMRC + #EXECTIME;
	    ELSE
	        #AR02_TMRDN := (#AR02_TMRC >= #AR_TMR_PSET);
	    END_IF;
	END_IF;
	
	// Timer Code for AutoRecovery Timer 03.
	IF NOT (#AR03_STRT) THEN
	    #AR03_TMRC := 0;
	    #AR03_TMRDN := FALSE;
	ELSE
	    IF (#AR03_TMRC <= #AR_TMR_PSET) THEN
	        #AR03_TMRC := #AR03_TMRC + #EXECTIME;
	    ELSE
	        #AR03_TMRDN := (#AR03_TMRC >= #AR_TMR_PSET);
	    END_IF;
	END_IF;
	

	
	// Part 2: Hold Condition:  If all inputs are in QBAD, hold last value.
	#QHOLD := #QERR_ALL;
	
	(**************************************************************************************************************)
	//ALARMING SECTION:
	IF #QERR_ALL THEN
	    
	    #Q_ANI := 1;
	    
	ELSIF (#QWARN_EN OR #QERR_MM) AND NOT #QERR_ALL THEN
	    
	    #Q_ANI := 2;
	    
	ELSE
	    
	    #Q_ANI := 0;
	    
	END_IF;
	
	
END_FUNCTION_BLOCK

